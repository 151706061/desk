<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>
VTK Mesh display
</title>
<script type="text/javascript" src="o3d-webgl/base.js"></script>
<script type="text/javascript" src="o3djs/base.js"></script>
<script type="text/javascript" id="o3dscript">
o3djs.base.o3d = o3d;
o3djs.require('o3djs.webgl');
o3djs.require('o3djs.math');
o3djs.require('o3djs.quaternions');
o3djs.require('o3djs.rendergraph');
o3djs.require('o3djs.pack');
o3djs.require('o3djs.arcball');
o3djs.require('o3djs.event');
//o3djs.require('o3djs.scene');
o3djs.require('o3djs.primitives');

// Events
// Run the init() function once the page has finished loading.
// Run the uninit() function when the page has is unloaded.
window.onload = init;
window.onunload = uninit;

// global variables
var g_o3d;
var g_math;
var g_pack;
var g_client;

var g_thisRot;
var g_lastRot;

var g_o3dWidth = -1;
var g_o3dHeight = -1;

var g_aball;
var g_viewInfo;
var g_camera = {
// eye: [0, 0, 4],
 eye: [0, 0, 10],
 target: [0, 0, 0]
// eye: [60, 60, 100],
// target: [60, 60, 60]
};

function createfromXML(file,pack,color) {
	var material=o3djs.material.createBasicMaterial(pack, g_viewInfo, color);
// change lighting parameters
//color = emissive + lightColor * (ambient * diffuse + diffuse * lighting + specular * lightingSpecular * specularFactor) 
	material.getParam('emissive').value = [0.1, 0.1, 0.1 , 0.08];
	material.getParam('ambient').value = [0.1, 0.1, 0.1, 0.005];
	material.getParam('specular').value = [0.1, 0.1, 0.1, 0.01];
	material.getParam('shininess').value=0.02;
	material.getParam('specularFactor').value = 0.1;
	material.getParam('lightColor').value = [0.7, 0.7, 0.7, 0.5];
//  var lightPositionParam = material.createParam('lightWorldPos','ParamFloat3');
//  o3djs.material.attachStandardEffect(pack, material, viewInfo, 'phong');

  // We have to set the light position after calling attachStandardEffect
  // because attachStandardEffect sets it based on the view.
//  lightPositionParam.value = [1000, 2000, 3000];

	var vertexInfo = o3djs.primitives.createVertexInfo();
	var positionStream = vertexInfo.addStream(
		3, o3djs.base.o3d.Stream.POSITION);
	var normalStream = vertexInfo.addStream(
		3, o3djs.base.o3d.Stream.NORMAL);

	if (window.XMLHttpRequest)
	{// code for IE7+, Firefox, Chrome, Opera, Safari
		var xmlhttp=new XMLHttpRequest();
	}
	else
	{// code for IE6, IE5
		var xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	}
	xmlhttp.open("GET",file,false);
	xmlhttp.send();
	var xmlDoc=xmlhttp.responseXML;

	var xmlString = (new XMLSerializer()).serializeToString(xmlDoc);

// get points
	var piece=xmlDoc.getElementsByTagName("Piece")[0];
	var numberOfPoints=parseInt(piece.getAttribute("NumberOfPoints"));
	var numberOfPolys=parseInt(piece.getAttribute("NumberOfPolys"));
	var points=piece.getElementsByTagName("Points")[0];

	var i=0;
	for (i=0;i<points.childNodes.length;i++)
	{
		var child=points.childNodes[i];
		if ((child.tagName == "DataArray") && (child.getAttribute("Name")=="Points"))
		{
			var numberOfComponents=parseInt(child.getAttribute("NumberOfComponents"));
			var pointsData;
			// IE supports the text property
			if (window.ActiveXObject) {
				pointsData = child.text;
			}
			// Other browsers use textContent
			else {
				pointsData = child.textContent;
			}
			var reg=new RegExp("[ ,;]+", "g");
			var pointsDataArray=trimAll(pointsData).split(reg)

			var j=0;
			var index=0;
			var index2=0;
			var Coord=[0,0,0];
			for (j=0;j<pointsDataArray.length;j++)
			{
				var value=parseFloat(pointsDataArray[j]);
				if (!isNaN(value))
				{
					Coord[index2]=value;
					index++;
					index2++;
					if (index2==3)
					{
						index2=0;
						positionStream.addElement(Coord[0],Coord[1],Coord[2]);
					}
					
				}
			}
			var wantedSize=numberOfComponents*numberOfPoints;
			if (index!=wantedSize)
			  alert ("Error reading "+file+" : \n Number of read coordinates : "+index+
			  "\n Number of wanted coordinates : "+ wantedSize);
		}
	}

//get triangles
	var polys=piece.getElementsByTagName("Polys")[0];
	for (var i=0;i<polys.childNodes.length;i++)
	{
		var child=polys.childNodes[i];
		if ((child.tagName == "DataArray") && (child.getAttribute("Name")=="connectivity"))
		{
			var connectivityData
			// IE supports the text property
			if (window.ActiveXObject) {
				connectivityData = child.text
			}
			// Other browsers use textContent
			else {
				connectivityData = child.textContent;
			}

			var reg=new RegExp("[ ,;]+", "g");
			var connectivityDataArray=trimAll(connectivityData).split(reg)

			var index=0;
			var index2=0;
			var connect=[0,0,0];
			for (var j=0;j<connectivityDataArray.length;j++)
			{
				var value=parseInt(connectivityDataArray[j]);
				if (!isNaN(value))
				{
					connect[index2]=value;
					index++;
					index2++;
					if (index2==3)
					{
						index2=0;
						vertexInfo.addTriangle(connect[0],connect[1],connect[2]);						
					}
				}
			}
			var wantedSize=3*numberOfPolys;
			if (index!=wantedSize)
			  alert ("Error reading "+file+" : \n Number of read indices : "+index+
			  "\n Number of wanted connectivities : "+ wantedSize);
		}
	}

// compute normals
	for (var i=0;i<numberOfPoints;i++)
		normalStream.addElement(0,0,0);

	for (var i=0;i<numberOfPolys;i++)
	{
		var triangle=vertexInfo.getTriangle(i);
		var positions = [];
		for (var ii = 0; ii < 3; ++ii)
		{
			positions[ii] = positionStream.getElementVector(triangle[ii]);
		}

		var v0 = o3djs.math.subVector(positions[1],positions[0]);
		var v1 = o3djs.math.subVector(positions[2],positions[1]);
		var normal=o3djs.math.normalize(o3djs.math.cross(v0, v1));
		for (var iii=0;iii<3;iii++)
		{
			var normal2=normalStream.getElementVector(triangle[iii]);
			normalStream.setElementVector(triangle[iii],
				o3djs.math.addVector(normal,normal2));
		}
	}

	for (var i=0;i<numberOfPoints;i++)
	{
		var normal=normalStream.getElementVector(i);
		normalStream.setElementVector(i,o3djs.math.normalize(normal));
	}
	return vertexInfo.createShape(pack, material);
}

function trimAll(sString) 
{ 
	while (sString.substring(0,1) == ' ') 
	{ 
	sString = sString.substring(1, sString.length); 
	} 
	while (sString.substring(sString.length-1, sString.length) == ' ') 
	{ 
	sString = sString.substring(0,sString.length-1); 
	} 
return sString; 
}

function updateClient() {
  // If we are in RENDERMODE_ON_DEMAND mode then set the render mode again
  // which will cause the client re-render the display.
  if (g_client.renderMode == g_o3d.Client.RENDERMODE_ON_DEMAND) {
    g_client.render();
  }
}

function renderCallback(renderEvent) {
  resize();
    g_client.renderMode = g_o3d.Client.RENDERMODE_ON_DEMAND;
}

/**
 * Creates the client area.
 */
function init() {
  o3djs.webgl.makeClients(initStep2);
}

function setClientSize() {
  var newWidth  = g_client.width;
  var newHeight = g_client.height;

  if (newWidth != g_o3dWidth || newHeight != g_o3dHeight) {
    g_o3dWidth = newWidth;
    g_o3dHeight = newHeight;

    // Set the perspective projection matrix
    g_viewInfo.drawContext.projection = g_math.matrix4.perspective(
      g_math.degToRad(45), g_o3dWidth / g_o3dHeight, 0.1, 100);

    // Sets a new area size for arcball.
    g_aball.setAreaSize(g_o3dWidth, g_o3dHeight);

    //o3djs.dump.dump("areaWidth: " + g_o3dWidth + "\n");
    //o3djs.dump.dump("areaHeight: " + g_o3dHeight + "\n");
  }
}

function resize() {
  setClientSize();
}

var g_dragging = false;

function startDragging(e) {
  g_lastRot = g_thisRot;
  g_aball.click([e.x, e.y]);
  g_dragging = true;
}

function drag(e) {
  if (g_dragging) {
    var rotationQuat = g_aball.drag([e.x, e.y]);
    var rot_mat = g_quaternions.quaternionToRotation(rotationQuat);
    g_thisRot = g_math.matrix4.mul(g_lastRot, rot_mat);
    var m = g_client.root.localMatrix;
    g_math.matrix4.setUpper3x3(m, g_thisRot);
    g_client.root.localMatrix = m;
    updateClient();
  }
}

function stopDragging(e) {
  g_dragging = false;
}

function scrollMe(e) {
  if (e.deltaY) {
    g_camera.eye =
        g_math.mulScalarVector((-e.deltaY < 0 ? 11 : 13) / 12, g_camera.eye);
    g_viewInfo.drawContext.view = g_math.matrix4.lookAt(g_camera.eye,
                                                        g_camera.target,
                                                        [0, 1, 0]);
    updateClient();
  }
}
/**
 * Initializes O3D, creates the object and sets up the transform and
 * render graphs.
 * @param {Array} clientElements Array of o3d object elements.
 */
function initStep2(clientElements) {
	// Initializes global variables and libraries.
	var o3dElement = clientElements[0];
	g_client = o3dElement.client;
	g_o3d = o3dElement.o3d;
	g_math = o3djs.math;

	g_quaternions = o3djs.quaternions;
	g_lastRot = g_math.matrix4.identity();
	g_thisRot = g_math.matrix4.identity();

	// Create a pack to manage the objects created.
	g_pack = g_client.createPack();

	// Create the render graph for a view.
	g_viewInfo = o3djs.rendergraph.createBasicView(
	  g_pack,
	  g_client.root,
	  g_client.renderGraphRoot,
	  [1, 1, 1, 1]);

	// Set up our view transformation to look towards the world origin where the
	// object is located.
	g_viewInfo.drawContext.view = g_math.matrix4.lookAt(
	g_camera.eye,
	g_camera.target,
	[0, 1, 0]);  // up

	g_aball = o3djs.arcball.create(100, 100);
	setClientSize();

	// Create the Shape for the mesh
	var Shape=createfromXML("bunny.xml",g_pack,[1,1,1,1]);
//	var Shape=createfromXML("hand.xml",g_pack,[1,1,1,1]);
//	var Shape=createfromXML("skull.xml",g_pack,[1,1,1,1]);
//	var Shape=createfromXML("heart.xml",g_pack,[1,1,1,1]);

	// Create a new transform and parent the Shape under it.
	var Transform = g_pack.createObject('Transform');
	Transform.addShape(Shape);

	// Parent the object's transform to the client root.
	Transform.parent = g_client.root;

	o3djs.event.addEventListener(o3dElement, 'mousedown', startDragging);
	o3djs.event.addEventListener(o3dElement, 'mousemove', drag);
	o3djs.event.addEventListener(o3dElement, 'mouseup', stopDragging);
	o3djs.event.addEventListener(o3dElement, 'wheel', scrollMe);

	// Set our render callback for animation.
	// This sets a function to be executed every time a frame is rendered.
	g_client.setRenderCallback(renderCallback);
	window.onresize = updateClient;
}

/**
 * Removes any callbacks so they don't get called after the page has unloaded.
 */
function uninit() {
  if (g_client) {
    g_client.cleanup();
  }
}

</script>
</head>
<body>
<h1>Mesh Display</h1>
This example shows a VTK mesh exported to ASCII xml
<br/>

<!-- Start of O3D plugin -->
<div id="o3d" style="width: 100%; height: 80%;"></div>
<!-- End of O3D plugin -->

</div>
</body>
</html>
